# 原码、反码、补码的基础概念和计算方法.
对于一个数，计算机要使用一定的编码方式进行存储。

## 原码
原码就是符号位加上十进制数转成二进制的值，即第一位表示符号, 其余位表示值。<br>
比如如果是8位二进制：

```
[+1] = [0000 0001]原
[-1] = [1000 0001]原
```

因为第一位是符号位, 所以8位二进制数的取值范围就是[1111 1111, 0111 1111]，即[-127, 127]。<br>
原码是人脑最容易理解和计算的表示方式。

## 反码
1. 正数的反码是其本身
2. 负数的反码是在其原码的基础上，符号位不变，其余各个位取反

```
[+1] = [0000 0001]原 = [0000 0001]反
[-1] = [1000 0001]原 = [1111 1110]反
```

如果一个反码表示的是负数，人脑无法直观的看出来它的数值，通常要将其转换成原码再计算。

## 补码
1. 正数的补码是其本身
2. 负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后 +1（即在反码的基础上 +1）

```
[+1] = [0000 0001]原 = [0000 0001]反 = [0000 0001]补
[-1] = [1000 0001]原 = [1111 1110]反 = [1111 1111]补
```

对于负数，补码表示方式也是人脑无法直观看出其数值的，通常也需要转换成原码在计算其数值。

# 为何要使用原码、反码和补码
因为人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。但是对于计算机，加减已经是最基础的运算，要设计的尽量简单。根据运算法则，减去一个正数等于加上它的相反数（负数），所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。

首先来看用原码计算十进制的表达式 1 - 1 = 0：

```
1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2
```

如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的。

为了解决原码做减法的问题, 出现了反码：

```
1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原
                 = [0000 0001]反 + [1111 1110]反 
                 = [1111 1111]反 
                 = [1000 0000]原 = -0 //使用反码计算得到的结果也是反码，需要再次转换成原码。

76 - 10 = 76 + (-10) = [01001100]原 + [10001010]原
                     = [01001100]反 + [11110101]反
                     = [101000001]反 = [01000010]反 //得到的值超过8bit，所以最高的1需要丢弃，丢弃后需要在最低位 +1
                     = [01000010]原 = 66
```

用反码计算减法，结果的真值部分是正确的。问题就出现在“0”这个特殊的数值上。虽然人们理解上+0和-0是一样的，但是0带符号是没有任何意义的。而且会有`[0000 0000]原`和`[1000 0000]原`两个编码表示0。并且，当计算结果溢出时需要额外进行 +1 操作，使得运算多了一步，效率降低。

补码的出现，解决了0的符号以及两个编码的问题：

```
1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原
                 = [0000 0001]反 + [1111 1110]反 
                 = [0000 0001]补 + [1111 1111]补 
                 = [0000 0000]补
                 = [0000 0000]原 = 0 

(-1) + (-127) = [1000 0001]原 + [1111 1111]原
              = [1111 1111]补 + [1000 0001]补
              = [1000 0000]补 = -0
```

这样0用`[0000 0000]`表示，-0则不存在了，还可以用以前的-0的补码`[1000 0000]补`表示`-128`。使用补码不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。但是注意因为实际上是使用-0的补码来表示-128，所以-128并没有原码和反码表示。这就是为什么8位二进制，使用原码或反码表示的范围为[-127, +127]，而使用补码表示的范围为[-128, 127]。

因为机器使用补码，所以对于编程中常用到的32位int类型，可以表示范围是：[-2^31, 2^31 - 1]，因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。

# 数学原理
介绍三个概念—— **模** 、 **补数** 、 **同余**。

> **模** 运算：求整数 a 除以 整数 m 的余数。<br>
  公式：a mod m = a - m ⌊a / m⌋, for m != 0<br>
  ⌊⌋是取下界符号<br><br>
  两个整数 a、b，若它们对整数 m 做模运算所得的余数相等，则称a、b对于模 m **同余** 。<br>
  记作 a ≡ b (mod m)。<br>
  读作 a 与 b 关于模 m 同余。<br><br>
  整数 a 加上 x 或减去 x 能等于模 m，则 x 称为 a 的 **补数** 。

根据同余可得：

```
(x - y) mod m = (x - y + m) mod m
              = (x + (m - y)) mod m
              = (x + ((m - 1) - y + 1)) mod m
```

所以在 mod m 的情况下，可以认为 `-y = ((m - 1) - y + 1)`。

在整数里，假设不算符号位还剩 n 位。m 就是所能表示整数的个数；m - 1 换算成二进制就是 n 位 1（除去表示整数 0 的情况），并且 n 位 1 减去任何一个 n 位的二进制其实就是按位取反，也就是反码！那么 (m - 1) - y + 1 就是 y 的反码加 1。也就是说，如果我们需要计算 x - y，只需要计算 x + (y 的反码 + 1)！
